# Flip Moment - 架构设计文档

## 架构概览

Flip Moment 采用 **Feature-First + Layered Architecture** 架构模式，结合现代 Flutter 开发最佳实践，构建了一个高度模块化、可扩展、可维护的应用程序架构。

### 架构原则

1. **关注点分离**: 清晰的分层架构，每层职责明确
2. **依赖倒置**: 高层模块不依赖低层模块，依赖抽象
3. **单一职责**: 每个模块和组件只负责一个功能
4. **开闭原则**: 对扩展开放，对修改关闭
5. **代码复用**: 通过抽象和接口实现代码复用

## 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer (表现层)                  │
├─────────────────────────────────────────────────────────────┤
│  features/decision  │  features/history  │  features/settings  │
│     presentation    │     presentation   │     presentation   │
│                     │                    │                    │
│  ┌───────────────┐  │  ┌───────────────┐ │  ┌───────────────┐ │
│  │ Decision      │  │  │ History       │ │  │ Settings      │ │
│  │ Screen        │  │  │ Screen        │ │  │ Screen        │ │
│  └───────────────┘  │  └───────────────┘ │  └───────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                      Domain Layer (领域层)                     │
├─────────────────────────────────────────────────────────────┤
│          core/providers/             │    features/*/        │
│        Riverpod Providers            │      Domain Logic     │
│                                     │                       │
│  ┌───────────────────────────────┐ │  ┌─────────────────┐   │
│  │  SkinProvider                 │ │  │ DecisionService │   │
│  │  DecisionHistoryProvider      │ │  │ UserService     │   │
│  │  SettingsProvider             │ │  │ ...             │   │
│  └───────────────────────────────┘ │  └─────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                                │
┌─────────────────────────────────────────────────────────────┐
│                      Data Layer (数据层)                      │
├─────────────────────────────────────────────────────────────┤
│  core/skin_engine/  │  core/skins/      │  features/*/data   │
│   AppSkin           │   Skin Impl       │   Data Models      │
│                     │                   │                    │
│  ┌─────────────────┐│  ┌──────────────┐ │  ┌──────────────┐   │
│  │ AppSkin         ││  │ VintageSkin  │ │  │ Decision     │   │
│  │ Protocol        ││  │ HealingSkin  │ │  │ Model        │   │
│  │                 ││  │ CyberSkin    │ │  │ User Model   │   │
│  │ SkinMode Enum   ││  │ WishSkin     │ │  │ ...          │   │
│  └─────────────────┘│  └──────────────┘ │  └──────────────┘   │
│                     │                   │                    │
│  core/services/     │                   │  services/storage/ │
│  - HapticService    │                   │  - Hive Database   │
│  - AudioService     │                   │  - Data Adapters   │
│  - PermissionService│                   │                    │
└─────────────────────────────────────────────────────────────┘
```

## 详细架构分析

### 1. Presentation Layer（表现层）

#### 设计目标
- 负责用户界面展示和用户交互
- 保持 UI 组件的简洁和可复用性
- 与领域层解耦，通过状态提供者获取数据

#### 核心组件

##### Feature-based 模块化设计
```
features/
├── decision/
│   ├── presentation/          # UI 展示层
│   │   ├── decision_screen.dart
│   │   └── widgets/
│   ├── domain/                # 业务逻辑层
│   │   ├── usecases/
│   │   └── repositories/
│   ├── data/                  # 数据实现层
│   │   ├── models/
│   │   └── repositories/
│   └── providers/             # 状态管理
├── history/
├── settings/
├── splash/
└── user/
```

##### UI 组件设计模式
```dart
// 遵循 StatefulWidget + Consumer 模式
class DecisionScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final skinState = ref.watch(skinProvider);
    
    return Scaffold(
      body: AnimatedBuilder(
        animation: skinState.controller,
        builder: (context, child) {
          return skinState.currentSkin.buildInteractiveHero(
            controller: skinState.controller,
            onTap: () => ref.read(decisionProvider.notifier).makeDecision(),
            onResult: (result) => _showResult(context, result),
          );
        },
      ),
    );
  }
}
```

### 2. Domain Layer（领域层）

#### 设计目标
- 封装核心业务逻辑
- 定义业务规则和约束
- 提供清晰的数据接口

#### 核心组件

##### Riverpod Provider 架构
```dart
// 状态提供者作为领域逻辑的入口
@riverpod
class DecisionNotifier extends _$DecisionNotifier {
  @override
  Future<List<DecisionModel>> build() async {
    return await _decisionRepository.getAllDecisions();
  }

  Future<void> makeDecision() async {
    final skinMode = ref.read(skinProvider).currentSkin.mode;
    final result = _generateRandomDecision();
    
    final decision = DecisionModel.create(
      result: result,
      skinMode: skinMode,
    );
    
    await _decisionRepository.saveDecision(decision);
    state = AsyncValue.data(await _decisionRepository.getAllDecisions());
  }
}
```

##### Service 层设计
```dart
// 领域服务封装核心业务逻辑
class DecisionService {
  static const List<String> _decisions = ['是', '否'];
  
  static String generateRandomDecision() {
    final random = Random();
    return _decisions[random.nextInt(_decisions.length)];
  }
  
  static bool isValidDecision(String decision) {
    return _decisions.contains(decision);
  }
}
```

### 3. Data Layer（数据层）

#### 设计目标
- 提供统一的数据访问接口
- 隐藏数据存储细节
- 支持多种数据源和缓存策略

#### 核心组件

##### Repository 模式
```dart
abstract class DecisionRepository {
  Future<List<DecisionModel>> getAllDecisions();
  Future<void> saveDecision(DecisionModel decision);
  Future<void> deleteDecision(String id);
}

class HiveDecisionRepository implements DecisionRepository {
  final HiveRepository _hiveRepository;
  
  @override
  Future<List<DecisionModel>> getAllDecisions() async {
    final box = await _hiveRepository.getBox<DecisionModel>('decisions_box');
    return box.values.toList()
      ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
  }
  
  @override
  Future<void> saveDecision(DecisionModel decision) async {
    final box = await _hiveRepository.getBox<DecisionModel>('decisions_box');
    await box.put(decision.id, decision);
  }
}
```

##### 数据模型设计
```dart
// 使用 Freezed 生成不可变数据类
@freezed
class DecisionModel with _$DecisionModel {
  @HiveType(typeId: 1)
  const factory DecisionModel({
    @HiveField(0) required String id,
    @HiveField(1) required DateTime timestamp,
    @HiveField(2) required String result,
    @HiveField(3) required String skinModeName,
  }) = _DecisionModel;
  
  factory DecisionModel.create({
    required String result,
    required SkinMode skinMode,
  }) {
    return DecisionModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      timestamp: DateTime.now(),
      result: result,
      skinModeName: skinMode.name,
    );
  }
}
```

## 核心设计模式

### 1. 抽象工厂模式 - 皮肤系统

#### 模式应用
皮肤系统采用抽象工厂模式，定义了统一的接口规范：

```dart
abstract class AppSkin {
  // 产品接口定义
  SkinMode get mode;
  Color get backgroundSurface;
  Color get primaryAccent;
  Widget buildInteractiveHero({
    required AnimationController controller,
    required VoidCallback onTap,
    Function(String)? onResult,
  });
}

// 具体工厂实现
class VintageSkin implements AppSkin {
  @override
  SkinMode get mode => SkinMode.vintage;
  
  @override
  Widget buildInteractiveHero({
    required AnimationController controller,
    required VoidCallback onTap,
    Function(String)? onResult,
  }) {
    return FrameCoinFlipper(
      skin: this,
      onFlipStart: onTap,
      onFlipEnd: onResult,
    );
  }
}
```

#### 优势
- **解耦**: UI 组件只依赖抽象接口，不关心具体实现
- **扩展性**: 新增皮肤只需要实现接口即可
- **复用性**: 统一的接口设计提高代码复用

### 2. Provider 模式 - 状态管理

#### Riverpod 状态管理
```dart
// Provider 定义
@riverpod
class SkinNotifier extends _$SkinNotifier {
  @override
  SkinState build() {
    return SkinState.initial();
  }

  void switchSkin(SkinMode mode) {
    final oldSkin = state.currentSkin;
    oldSkin.dispose(); // 清理旧资源
    
    final newSkin = _createSkin(mode);
    state = state.copyWith(
      currentSkin: newSkin,
      mode: mode,
    );
  }
  
  AppSkin _createSkin(SkinMode mode) {
    switch (mode) {
      case SkinMode.vintage:
        return VintageSkin();
      case SkinMode.healing:
        return HealingSkin();
      // ...
    }
  }
}
```

### 3. Repository 模式 - 数据访问

#### 分层数据访问
```dart
// 抽象仓库接口
abstract class IDataRepository<T> {
  Future<T> getById(String id);
  Future<List<T>> getAll();
  Future<void> save(T entity);
  Future<void> delete(String id);
}

// 具体实现
class HiveRepository<T> implements IDataRepository<T> {
  final String boxName;
  final TypeAdapter<T> adapter;
  
  @override
  Future<Box<T>> getBox() async {
    return await Hive.openBox<T>(boxName);
  }
}
```

## 架构优势分析

### 1. 可维护性
- **清晰的模块划分**: 每个功能模块独立开发
- **松耦合设计**: 模块间依赖关系简单
- **单一职责**: 每个组件职责明确

### 2. 可扩展性
- **插件化架构**: 新功能可以独立添加
- **皮肤系统扩展**: 新皮肤可以快速接入
- **服务接口统一**: 新服务实现统一接口即可

### 3. 可测试性
- **依赖注入**: 便于单元测试和集成测试
- **接口隔离**: 可以轻松模拟依赖
- **业务逻辑独立**: 业务逻辑可以单独测试

### 4. 性能优化
- **懒加载**: 资源按需加载
- **内存管理**: 智能缓存和资源释放
- **状态优化**: 精准的状态更新控制

## 技术选型分析

### 1. Flutter 框架
**选择原因**:
- 跨平台开发，减少开发成本
- 优秀的渲染性能，支持复杂动画
- 丰富的生态系统

### 2. Riverpod 状态管理
**选择原因**:
- 类型安全的依赖注入
- 优秀的性能表现
- 简单易用的 API

### 3. Hive 数据库
**选择原因**:
- 高性能本地存储
- 优秀的类型安全支持
- 易于使用的 API

### 4. Rive 动画
**选择原因**:
- 强大的矢量动画能力
- 运行时渲染优化
- 设计师友好的工作流

## 架构演进规划

### 当前架构特点
- **基础架构稳定**: 核心架构模式已经建立
- **功能模块清晰**: 四大皮肤系统功能完善
- **技术栈成熟**: 所有依赖都是成熟稳定的版本

### 未来演进方向

#### 1. 微服务化
- 将不同功能模块独立部署
- 通过 API 网关统一管理

#### 2. 插件化框架
- 皮肤系统模块化
- 第三方皮肤插件支持

#### 3. 云端集成
- 云端数据同步
- 用户画像分析

#### 4. AI 增强
- 智能决策建议
- 个性化皮肤推荐

## 总结

Flip Moment 的架构设计充分体现了现代移动应用开发的最佳实践：

1. **清晰的架构层次**: 三层架构确保关注点分离
2. **优秀的扩展性**: 抽象工厂和接口设计支持快速扩展
3. **高性能实现**: 优化缓存和内存管理保证流畅体验
4. **现代化工具链**: 使用最新的 Flutter 和 Dart 生态工具

通过这种架构设计，Flip Moment 不仅能够满足当前的功能需求，还为未来的功能扩展和性能优化奠定了坚实的基础。架构的可维护性、可扩展性和可测试性都得到了很好的保证，是一个值得借鉴的 Flutter 应用架构设计范例。

---

*本文档详细阐述了 Flip Moment 应用的技术架构设计原理和实现细节*