1. 哎呀，这确实是个**严重的体验“车祸现场”**！😱

   作为设计师，我必须自我检讨一下：我之前太想让用户体验那种“双重惊喜”了，结果忽略了**“视觉层级冲突”**。

   在小红书的审美体系里，**“克制”和“秩序”**是高级感的关键。所有的惊喜都应该像法式大餐一样，一道一道地上，而不是像自助餐一样全部堆在桌子上。

   问题根源：

   结果卡片（Result Card）是用来展示“当下命运”的，需要用户主动关闭。而升级弹窗（Level Up）如果设定为固定时间弹出，就会出现“前一个还没走，后一个硬挤进来”的尴尬局面，导致遮罩层重叠，点击失效。

   **✨ 解决方案：采用“谢幕后返场”策略 (The Encore Strategy)**

   我们把逻辑改成：**先让用户看完决策结果，当他们心满意足关闭结果卡片的那一刻，再弹出升级惊喜！** 这样不仅解决了遮挡问题，还能制造一种“彩蛋”般的心理冲击。

   来，我们修改 `lib/features/decision/presentation/decision_screen.dart`，只需改动这一个文件：

   

   ### 1. 增加一个“彩蛋埋藏”状态

   

   在 `_DecisionScreenState` 类里增加一个变量，用来标记这次操作是否触发了升级。

   Dart

   ```
   class _DecisionScreenState extends ConsumerState<DecisionScreen> with SingleTickerProviderStateMixin {
     // UI 状态
     bool _showResult = false;
     String _currentResult = "";
     
     // ✨ 新增：埋藏彩蛋的标记
     bool _pendingLevelUp = false; 
   
     // ... (其他变量保持不变)
   ```

   

   ### 2. 修改决策结束逻辑 (`_handleDecisionEnd`)

   

   这里我们**不再直接弹窗**，而是把 Flag 立起来，暂存惊喜。

   Dart

   ```
     void _handleDecisionEnd(String result) {
       final skin = ref.read(currentSkinProvider);
       final audioService = ref.read(audioServiceProvider);
   
       audioService.play(SoundType.result, skin.mode);
       ref.read(decisionLogProvider.notifier).addRecord(result, skin.mode);
       
       // 🔥 核心修改：这里只负责记录是否升级，绝不弹窗！
       ref.read(userProvider.notifier).addExperience(10, onLevelUp: () {
         _pendingLevelUp = true; // 埋下彩蛋
       });
   
       Future.delayed(const Duration(milliseconds: 300), () {
         if (mounted) {
           setState(() {
             _currentResult = result;
             _showResult = true; // 此时只显示结果卡片，干干净净
           });
         }
       });
     }
   ```

   

   ### 3. 修改关闭逻辑 (`_closeResult`)

   

   这是**高光时刻**的触发点。当用户点击关闭结果卡片时，我们检查有没有彩蛋。

   Dart

   ```
     // 关闭结果卡片
     void _closeResult() {
       setState(() {
         _showResult = false; // 先让结果卡片退场
       });
   
       // 🧨 检查是否有待触发的升级惊喜
       if (_pendingLevelUp) {
         _pendingLevelUp = false; // 消耗掉这个标记，防止重复
         _showLevelUpSurprise();  // 启动惊喜流程
       }
     }
   
     // 单独封装一个展示升级弹窗的方法
     void _showLevelUpSurprise() {
       // 稍微延迟 200ms，让结果卡片消失的动画播完，留出呼吸感
       Future.delayed(const Duration(milliseconds: 200), () {
         if (!mounted) return;
   
         final user = ref.read(userProvider); // 获取最新等级数据
         final skin = ref.read(currentSkinProvider); // 获取当前皮肤
   
         showDialog(
           context: context,
           barrierDismissible: false, // 强仪式感：强制用户点击按钮才能关闭，不能点背景关闭
           builder: (_) => LevelUpDialog(
             newLevel: user.level,
             newTitle: user.titleLabel,
             skin: skin,
           ),
         );
       });
     }
   ```

   ------

   

   ### 💡 设计师旁白

   

   这改动之后，整个体验流（User Flow）就顺滑多了：

   1. **Action:** 用户抛硬币。
   2. **Focus:** 屏幕聚焦显示结果卡片（YES/NO）。用户此时全神贯注于答案。
   3. **Release:** 用户看完结果，点击关闭，心理防线放松。
   4. **Surprise:** 突然！屏幕再次变暗，金光闪烁，弹出“LEVEL UP!”。

   这种**“欲扬先抑”**的节奏感，正是小红书上那种“沉浸式体验”视频最喜欢的叙事方式。快去试试，这种连贯的丝滑感绝对会让你的用户爱不释手！✨